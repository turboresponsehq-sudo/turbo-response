#!/usr/bin/env node

/**
 * Daily Task Creator
 * 
 * Creates 3-5 GitHub issues from daily intel report action items
 * 
 * Runs: 7:00am ET daily via GitHub Actions
 * Input: /docs/intel-reports/intel-YYYY-MM-DD.md
 * Output: GitHub issues with due dates
 */

const https = require('https');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  github: {
    owner: 'turboresponsehq-sudo',
    repo: 'turbo-response',
    token: process.env.GITHUB_TOKEN || '',
  },
  reportDir: './docs/intel-reports',
  timezone: 'America/New_York',
  maxTasksPerDay: 5,
  priorityToDueDate: {
    P0: 0,  // Today
    P1: 3,  // 3 days
    P2: 7,  // 7 days
  },
};

// Utility: Get today's date in ET
function getDateET() {
  const now = new Date();
  const etOffset = -5 * 60;
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  const etTime = new Date(utc + (etOffset * 60000));
  return etTime.toISOString().split('T')[0];
}

// Utility: Calculate due date based on priority
function calculateDueDate(priority) {
  const daysToAdd = CONFIG.priorityToDueDate[priority] || 7;
  const now = new Date();
  const dueDate = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
  return dueDate.toISOString().split('T')[0]; // YYYY-MM-DD
}

// Utility: Make HTTPS request
function httpsRequest(options, body = null) {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        try {
          resolve({ status: res.statusCode, body: JSON.parse(data) });
        } catch (e) {
          resolve({ status: res.statusCode, body: data });
        }
      });
    });
    req.on('error', reject);
    if (body) req.write(body);
    req.end();
  });
}

// Parser: Extract action items from markdown report
function parseActionItems(markdown) {
  const actionItems = [];
  
  // Extract action items section (handle both single and double newlines)
  const actionItemsSection = markdown.match(/## üéØ Action Items\n([\s\S]+?)\n---/);
  if (!actionItemsSection) {
    console.log('‚ö†Ô∏è No action items section found in report');
    return actionItems;
  }

  // Parse each action item (handle priority subsections like ### P0 - Critical)
  // Allow single newlines between fields
  const itemMatches = actionItemsSection[1].matchAll(/#### \d+\. (.+?)\n\*\*Category:\*\* (.+?)\n\*\*Description:\*\* (.+?)\n\*\*Action Required:\*\* (.+?)(?:\n\*\*Links:\*\*\n([\s\S]+?))?(?=\n###|\n####|\n---|$)/gs);
  
  for (const match of itemMatches) {
    const [, title, category, description, action, linksSection] = match;
    
    // Determine priority from title emoji
    let priority = 'P2';
    if (title.includes('üö®')) priority = 'P0';
    else if (title.includes('‚ö†Ô∏è') || title.includes('üêõ')) priority = 'P1';
    
    // Extract links if present
    const links = [];
    if (linksSection) {
      const linkMatches = linksSection.matchAll(/- (.+)/g);
      for (const linkMatch of linkMatches) {
        links.push(linkMatch[1].trim());
      }
    }
    
    actionItems.push({
      priority,
      title: title.trim(),
      category: category.trim(),
      description: description.trim(),
      action: action.trim(),
      links,
    });
  }

  return actionItems;
}

// Filter: Select top tasks to create
function selectTasksToCreate(actionItems) {
  // Sort by priority (P0 > P1 > P2)
  const priorityOrder = { P0: 0, P1: 1, P2: 2 };
  const sorted = actionItems.sort((a, b) => 
    priorityOrder[a.priority] - priorityOrder[b.priority]
  );

  // Take top N tasks (max 5)
  const selected = sorted.slice(0, CONFIG.maxTasksPerDay);

  // Skip "All systems nominal" task
  const filtered = selected.filter(item => 
    !item.title.includes('All systems nominal')
  );

  return filtered;
}

// GitHub: Create issue
async function createGitHubIssue(task) {
  console.log(`[GitHub] Creating issue: ${task.title}`);

  const dueDate = calculateDueDate(task.priority);
  
  // Build issue body
  let body = `**Priority:** ${task.priority}\n`;
  body += `**Category:** ${task.category}\n`;
  body += `**Due Date:** ${dueDate}\n\n`;
  body += `---\n\n`;
  body += `## Description\n\n${task.description}\n\n`;
  body += `## Action Required\n\n${task.action}\n\n`;
  
  if (task.links && task.links.length > 0) {
    body += `## Related Links\n\n`;
    task.links.forEach(link => {
      body += `- ${link}\n`;
    });
    body += `\n`;
  }
  
  body += `---\n\n`;
  body += `*Auto-generated by Daily Intel System on ${new Date().toLocaleDateString('en-US', { timeZone: 'America/New_York' })}*\n`;

  // Determine labels based on priority and category
  const labels = ['intel-task'];
  if (task.priority === 'P0') labels.push('critical', 'bug');
  else if (task.priority === 'P1') labels.push('high-priority');
  else labels.push('enhancement');

  if (task.category.toLowerCase().includes('bug')) labels.push('bug');
  if (task.category.toLowerCase().includes('production')) labels.push('production');

  // Create issue via GitHub API
  const issueData = {
    title: `[${task.priority}] ${task.title}`,
    body: body,
    labels: labels,
  };

  const options = {
    hostname: 'api.github.com',
    path: `/repos/${CONFIG.github.owner}/${CONFIG.github.repo}/issues`,
    method: 'POST',
    headers: {
      'User-Agent': 'TurboResponse-Task-Creator',
      'Authorization': `token ${CONFIG.github.token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
  };

  try {
    const res = await httpsRequest(options, JSON.stringify(issueData));
    
    if (res.status === 201) {
      console.log(`‚úÖ Issue created: #${res.body.number} - ${res.body.html_url}`);
      return {
        success: true,
        number: res.body.number,
        url: res.body.html_url,
      };
    } else {
      console.error(`‚ùå Failed to create issue: ${res.status}`, res.body);
      return {
        success: false,
        error: res.body,
      };
    }
  } catch (error) {
    console.error(`‚ùå Error creating issue: ${error.message}`);
    return {
      success: false,
      error: error.message,
    };
  }
}

// Main execution
async function main() {
  console.log('=== Daily Task Creator ===');
  console.log(`Starting task creation at ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })} ET\n`);

  // Load today's report
  const date = getDateET();
  const reportPath = path.join(CONFIG.reportDir, `intel-${date}.md`);

  if (!fs.existsSync(reportPath)) {
    console.error(`‚ùå Report not found: ${reportPath}`);
    console.error('Run daily-intel-scanner.js first to generate report');
    process.exit(1);
  }

  const markdown = fs.readFileSync(reportPath, 'utf8');
  console.log(`‚úÖ Loaded report: ${reportPath}\n`);

  // Parse action items
  const actionItems = parseActionItems(markdown);
  console.log(`Found ${actionItems.length} action items\n`);

  if (actionItems.length === 0) {
    console.log('No action items to create tasks from');
    return { tasksCreated: 0, results: [] };
  }

  // Select tasks to create
  const tasksToCreate = selectTasksToCreate(actionItems);
  console.log(`Selected ${tasksToCreate.length} tasks to create:\n`);
  
  tasksToCreate.forEach((task, index) => {
    console.log(`${index + 1}. [${task.priority}] ${task.title}`);
  });
  console.log('');

  // Create GitHub issues
  const results = [];
  for (const task of tasksToCreate) {
    const result = await createGitHubIssue(task);
    results.push({
      task,
      result,
    });
    
    // Rate limiting: wait 1 second between requests
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  // Summary
  const successCount = results.filter(r => r.result.success).length;
  const failureCount = results.filter(r => !r.result.success).length;

  console.log('\n=== Task Creation Summary ===');
  console.log(`Total: ${results.length}`);
  console.log(`Success: ${successCount}`);
  console.log(`Failed: ${failureCount}`);

  if (successCount > 0) {
    console.log('\n‚úÖ Created issues:');
    results
      .filter(r => r.result.success)
      .forEach(r => {
        console.log(`  #${r.result.number}: ${r.task.title}`);
        console.log(`  ${r.result.url}`);
      });
  }

  if (failureCount > 0) {
    console.log('\n‚ùå Failed to create:');
    results
      .filter(r => !r.result.success)
      .forEach(r => {
        console.log(`  ${r.task.title}`);
        console.log(`  Error: ${r.result.error}`);
      });
  }

  return {
    tasksCreated: successCount,
    results,
  };
}

// Run if called directly
if (require.main === module) {
  main()
    .then((result) => {
      console.log(`\n‚úÖ Task creation complete: ${result.tasksCreated} tasks created`);
      process.exit(0);
    })
    .catch(error => {
      console.error('\n‚ùå Task creation failed:', error);
      process.exit(1);
    });
}

module.exports = { main, parseActionItems, selectTasksToCreate, createGitHubIssue };
